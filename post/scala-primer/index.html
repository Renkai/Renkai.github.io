<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <title>
    scala 从入门到入门&#43; // Renkai&#39;s blog
  </title>

  <link href="http://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="">
<meta name="generator" content="Hugo 0.14" />

  <meta property="og:title" content="scala 从入门到入门&#43;" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="http://localhost:1313/post/scala-primer/" />


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/base-min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/pure-min.css">
  
  
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/grids-responsive-min.css">
  
  

  <link rel="stylesheet" href="http://localhost:1313//css/redlounge.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='//fonts.googleapis.com/css?family=Raleway:400,200,100,700,300,500,600,800' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Renkai&#39;s blog" />

    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/tomorrow-night-bright.min.css">
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  

  

  
</head>

<body>
	

	<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
  <div class="header">
    

    <h1 class="brand-title">Renkai&#39;s Blog</h1>
    <h2 class="brand-tagline">Happy Hacking</h2>

    <nav class="nav">
      <ul class="nav-list">
        <li class="nav-item"><span class="nav-item-separator">//</span><a href="http://localhost:1313/">Home</a></li>
        
      </ul>
    </nav>

    
    <div class="social-buttons">
      
        
        <a href="http://weibo.com/renkai1991" target="_blank"><i class='fa fa-weibo'></i></a>
        
      
        
        <a href="https://github.com/Renkai" target="_blank"><i class='fa fa-github'></i></a>
        
      
        
        <a href="http://stackoverflow.com/users/2655102/renkai" target="_blank"><i class='fa fa-stack-overflow'></i></a>
        
      
      
    </div>
    

  </div>
</div>

	
	

    <div class="content pure-u-1 pure-u-md-3-4">
		<a name="top"></a>
		

		
			
		    <div id="toc" class="pure-u-1 pure-u-md-1-4">
				<small class="toc-label">Contents</small>
		   	 	<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#从语句到表达式:0cf58323c62a1ce60f25579926a25322">从语句到表达式</a></li>
<li><a href="#纯函数和非纯函数:0cf58323c62a1ce60f25579926a25322">纯函数和非纯函数</a>
<ul>
<li><a href="#纯函数的好处-来自维基百科:0cf58323c62a1ce60f25579926a25322">纯函数的好处(来自维基百科)</a></li>
<li><a href="#纯函数的好处-来自我的经验:0cf58323c62a1ce60f25579926a25322">纯函数的好处(来自我的经验)</a></li>
</ul></li>
<li><a href="#惰性求值-call-by-name:0cf58323c62a1ce60f25579926a25322">惰性求值/Call by name</a>
<ul>
<li><a href="#惰性求值不是新鲜事:0cf58323c62a1ce60f25579926a25322">惰性求值不是新鲜事</a></li>
<li><a href="#用lazy关键词指定惰性求值:0cf58323c62a1ce60f25579926a25322">用lazy关键词指定惰性求值</a></li>
<li><a href="#call-by-value-就是函数参数的惰性求值:0cf58323c62a1ce60f25579926a25322">Call by value 就是函数参数的惰性求值</a></li>
<li><a href="#一个例子-假设你要建立一个本地缓存:0cf58323c62a1ce60f25579926a25322">一个例子,假设你要建立一个本地缓存</a></li>
</ul></li>
<li><a href="#tuple-case-class-模式匹配:0cf58323c62a1ce60f25579926a25322">Tuple/case class/模式匹配</a>
<ul>
<li><a href="#tuple为编程提供许多便利:0cf58323c62a1ce60f25579926a25322">Tuple为编程提供许多便利</a></li>
<li><a href="#使用tuple的例子:0cf58323c62a1ce60f25579926a25322">使用tuple的例子</a></li>
<li><a href="#用模式匹配增加tuple可读性:0cf58323c62a1ce60f25579926a25322">用模式匹配增加tuple可读性</a></li>
<li><a href="#match和java和switch很像-但有区别:0cf58323c62a1ce60f25579926a25322">match和java和switch很像,但有区别</a></li>
<li><a href="#case-class:0cf58323c62a1ce60f25579926a25322">Case class</a></li>
</ul></li>
<li><a href="#用-option-代替-null:0cf58323c62a1ce60f25579926a25322">用 option 代替 null</a>
<ul>
<li><a href="#null-的问题:0cf58323c62a1ce60f25579926a25322">null 的问题</a></li>
<li><a href="#option介绍:0cf58323c62a1ce60f25579926a25322">option介绍</a></li>
<li><a href="#看看scala的map:0cf58323c62a1ce60f25579926a25322">看看scala的map</a></li>
<li><a href="#好像没有太大区别:0cf58323c62a1ce60f25579926a25322">好像没有太大区别?</a></li>
<li><a href="#试试容器里的各种方法:0cf58323c62a1ce60f25579926a25322">试试容器里的各种方法</a></li>
<li><a href="#option配合其他容器使用:0cf58323c62a1ce60f25579926a25322">option配合其他容器使用</a></li>
</ul></li>
<li><a href="#用try类保存异常:0cf58323c62a1ce60f25579926a25322">用Try类保存异常</a>
<ul>
<li><a href="#传统异常处理的局限性:0cf58323c62a1ce60f25579926a25322">传统异常处理的局限性</a></li>
</ul></li>
<li><a href="#函数是一等公民:0cf58323c62a1ce60f25579926a25322">函数是一等公民</a>
<ul>
<li><a href="#一个需求:0cf58323c62a1ce60f25579926a25322">一个需求</a></li>
</ul></li>
<li><a href="#关于性能:0cf58323c62a1ce60f25579926a25322">关于性能</a>
<ul>
<li><a href="#总的来说-程序员越自由-程序性能就越差:0cf58323c62a1ce60f25579926a25322">总的来说,程序员越自由,程序性能就越差</a></li>
</ul></li>
<li><a href="#推荐资源:0cf58323c62a1ce60f25579926a25322">推荐资源</a></li>
</ul></li>
</ul>
</nav>
		    </div>
		    
	    
  		<section class="post">
            <h1 class="post-title">
              <a href="/post/scala-primer/">scala 从入门到入门&#43;</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>
            
            	<span class="post-date">
                	<span class="post-date-day"><sup>14</sup></span><span class="post-date-separator">/</span><span class="post-date-month">Aug</span> <span class="post-date-year">2015</span>
            	</span>
            	
            
            	
            

			
			

			

			

            

<p>新手向,面向刚从java过渡到scala的同学,目的是写出已已易于维护和阅读的代码.</p>

<h2 id="从语句到表达式:0cf58323c62a1ce60f25579926a25322">从语句到表达式</h2>

<blockquote>
<p>语句(statement): 一段可执行的代码
表达式(expression): 一段可以被求值的代码</p>
</blockquote>

<p>在Java中语句和表达式是有区分的,表达式必须在return或者等号右侧,而在scala中,一切都是表达式.</p>

<p>一个例子:
假设我们在公司的内网和外网要从不同的域名访问一样的机器</p>

<pre><code>//Java代码
String urlString = null;
String hostName = InetAddress.getLocalHost().getHostName();
if (isInnerHost(hostName)) {
  urlString = &quot;http://inner.host&quot;;
} else {
  urlString = &quot;http://outter.host&quot;;
}
</code></pre>

<p>刚转到scala的人很可能这么写</p>

<pre><code>var urlString: String = null
var hostName = InetAddress.getLocalHost.getHostName
if (isInnerHost(hostName)) {
  urlString = &quot;http://inner.host&quot;
} else {
  urlString = &quot;http://outter.host&quot;
}
</code></pre>

<p>我们让它更像scala一点吧</p>

<pre><code>val hostName = InetAddress.getLocalHost.getHostName
val urlString = if (isInnerHost(hostName)) {
  &quot;http://inner.host&quot;
} else {
  &quot;http://outter.host&quot;
}
</code></pre>

<blockquote>
<p>这样做的好处都有啥?</p>
</blockquote>

<ol>
<li>代码简练,符合直觉</li>
<li>urlString 是值而不是变量,有效防止 urlString 在后续的代码中被更改(编译时排错)</li>
</ol>

<p>很多时候,我们编程时说的安全并不是指怕被黑客破坏掉,而是预防自己因为逗比而让程序崩了.</p>

<h2 id="纯函数和非纯函数:0cf58323c62a1ce60f25579926a25322">纯函数和非纯函数</h2>

<p>纯函数（Pure Function）是这样一种函数——输入输出数据流全是显式（Explicit）的。
显式（Explicit）的意思是，函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</p>

<p>如果一个函数通过隐式（Implicit）方式，从外界获取数据，或者向外部输出数据，那么，该函数就不是纯函数，叫作非纯函数（Impure Function）。
隐式（Implicit）的意思是，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如，读取全局变量，修改全局变量，都叫作以隐式的方式和外界进行数据交换；比如，利用I/O API（输入输出系统函数库）读取配置文件，或者输出到文件，打印到屏幕，都叫做隐式的方式和外界进行数据交换。</p>

<pre><code>//一些例子
//纯函数
def add(a:Int,b:Int) = a + b
//非纯函数
var a = 1
def addA(b:Int) = a + b
 
def add(a:Int,b:Int) = {
  println(s&quot;a:$a b:$b&quot;)
  a + b
}
def randInt() = Random.nextInt()
</code></pre>

<h3 id="纯函数的好处-来自维基百科:0cf58323c62a1ce60f25579926a25322">纯函数的好处(来自维基百科)</h3>

<ul>
<li>无状态,线程安全,不需要线程同步.</li>
<li>纯函数相互调用组装起来的函数,还是纯函数.</li>
<li>应用程序或者运行环境(Runtime)可以对纯函数的运算结果进行缓存,运算加快速度.</li>
</ul>

<h3 id="纯函数的好处-来自我的经验:0cf58323c62a1ce60f25579926a25322">纯函数的好处(来自我的经验)</h3>

<ul>
<li>单元测试非常方便!</li>
<li>分布式/并发环境下,断点调试的方式无以为继,你需要单元测试.</li>
</ul>

<p>单元测试什么的,赶紧去 <a href="http://www.scalatest.org">http://www.scalatest.org</a> 试试吧</p>

<h2 id="惰性求值-call-by-name:0cf58323c62a1ce60f25579926a25322">惰性求值/Call by name</h2>

<blockquote>
<p>维基百科中惰性求值的解释
惰性求值（Lazy Evaluation），又称惰性计算、懒惰求值，是一个计算机编程中的一个概念，它的目的是要最小化计算机要做的工作。它有两个相关而又有区别的含意，可以表示为“延迟求值”和“最小化求值”，本条目专注前者，后者请参见最小化计算条目。除可以得到性能的提升外，惰性计算的最重要的好处是它可以构造一个无限的数据类型。
惰性求值的相反是及早求值，这是一个大多数编程语言所拥有的普通计算方式。</p>
</blockquote>

<h3 id="惰性求值不是新鲜事:0cf58323c62a1ce60f25579926a25322">惰性求值不是新鲜事</h3>

<pre><code>import scala.io.Source.fromFile
val iter: Iterator[String] =
  fromFile(&quot;sampleFile&quot;)
    .getLines()
</code></pre>

<p>文件迭代器就用到了惰性求值.
用户可以完全像操作内存中的数据一样操作文件,然而文件只有一小部分传入了内存中.</p>

<h3 id="用lazy关键词指定惰性求值:0cf58323c62a1ce60f25579926a25322">用lazy关键词指定惰性求值</h3>

<pre><code>lazy val firstLazy = {
  println(&quot;first lazy&quot;)
  1
}
lazy val secondLazy = {
  println(&quot;second lazy&quot;)
  2
} 
def add(a:Int,b:Int) = {
  a+b
}
</code></pre>

<pre><code>//在 scala repl 中的结果
scala&gt; add(secondLazy,firstLazy)
second lazy
first lazy
res0: Int = 3

res0: Int = 3
</code></pre>

<p>second lazy 先于 first lazy输出了</p>

<h3 id="call-by-value-就是函数参数的惰性求值:0cf58323c62a1ce60f25579926a25322">Call by value 就是函数参数的惰性求值</h3>

<pre><code>def firstLazy = {
  println(&quot;first lazy&quot;)
  1
}
def secondLazy = {
  println(&quot;second lazy&quot;)
  2
}
def chooseOne(first: Boolean, a: Int, b: Int) = {
  if (first) a else b
}
def chooseOneLazy(first: Boolean, a: =&gt; Int, b: =&gt; Int) = {
  if (first) a else b
}
</code></pre>

<pre><code>chooseOne(first = true, secondLazy, firstLazy)
//second lazy
//first lazy
//res0: Int = 2
chooseOneLazy(first = true, secondLazy, firstLazy)
//second lazy
//res1: Int = 2
</code></pre>

<p>对于非纯函数,惰性求值会产生和立即求值产生不一样的结果.</p>

<h3 id="一个例子-假设你要建立一个本地缓存:0cf58323c62a1ce60f25579926a25322">一个例子,假设你要建立一个本地缓存</h3>

<pre><code>//需要查询mysql等,可能来自于一个第三方jar包
def itemIdToShopId: Int =&gt; Int  
var cache = Map.empty[Int, Int]
def cachedItemIdToShopId(itemId: Int):Int = {
  cache.get(itemId) match {
    case Some(shopId) =&gt; shopId
    case None =&gt;
      val shopId = itemIdToShopId(itemId)
      cache += itemId -&gt; shopId
      shopId
  }
}
</code></pre>

<ul>
<li>罗辑没什么问题,但测试的时候不方便连mysql怎么办?</li>
<li>如果第三方jar包发生了改变,cachedItemIdToShopId也要发生改变.</li>
</ul>

<pre><code>//用你的本地mock来测试程序
def mockItemIdToSHopId: Int =&gt; Int
def cachedItemIdToShopId(itemId: Int): Int ={  
  cache.get(itemId) match { 
    case Some(shopId) =&gt; shopId
   case None =&gt; 
      val shopId = mockItemIdToSHopId(itemId)
      cache += itemId -&gt; shopId
     shopId 
  } 
}   
</code></pre>

<ul>
<li>在测试的时候用mock,提交前要换成线上的,反复测试的话要反复改动,非常令人沮丧.</li>
<li>手工操作容易忙中出错.</li>
</ul>

<pre><code>//将远程请求的结果作为函数的一个参数
def cachedItemIdToShopId(itemId: Int, remoteShopId: Int): Int = {   
  cache.get(itemId) match { 
    case Some(shopId) =&gt; shopId 
    case None =&gt;    
     val shopId = remoteShopId  
     cache += itemId -&gt; shopId  
      shopId
  } 
}
//调用这个函数
cachedItemIdToShopId(itemId,itemIdToShopId(itemId))
</code></pre>

<ul>
<li>函数对mysql的依赖没有了</li>
<li>不需要在测试和提交时切换代码</li>
<li>貌似引入了新问题?</li>
</ul>

<p>没错,cache根本没有起应有的作用,函数每次执行的时候都调用了itemIdToShopId从远程取数据</p>

<pre><code>//改成call by name就没有这个问题啦
def cachedItemIdToShopId(itemId: Int, remoteShopId: =&gt;Int): Int = { 
  cache.get(itemId) match { 
    case Some(shopId) =&gt; shopId 
    case None =&gt;    
     val shopId = remoteShopId  
     cache += itemId -&gt; shopId  
      shopId
  } 
}
//调用这个函数
cachedItemIdToShopId(itemId,itemIdToShopId(itemId))
</code></pre>

<ul>
<li>函数对mysql的依赖没有了</li>
<li>不需要在测试和提交时切换代码</li>
<li>只在需要的时候查询远程库</li>
</ul>

<h2 id="tuple-case-class-模式匹配:0cf58323c62a1ce60f25579926a25322">Tuple/case class/模式匹配</h2>

<h3 id="tuple为编程提供许多便利:0cf58323c62a1ce60f25579926a25322">Tuple为编程提供许多便利</h3>

<ul>
<li>函数可以通过tuple返回多个值</li>
<li>tuple可以存储在容器类中,代替java bean</li>
<li>可以一次为多个变量赋值</li>
</ul>

<h3 id="使用tuple的例子:0cf58323c62a1ce60f25579926a25322">使用tuple的例子</h3>

<pre><code>val (one, two) = (1, 2)     
one //res0: Int = 1 
two //res1: Int = 2         
def sellerAndItemId(orderId: Int): (Int, Int) =
   orderId match {  
    case 0 =&gt; (1, 2)    
 }          
val (sellerId, itemId) = sellerAndItemId(0)
sellerId // sellerId: Int = 1
itemId // itemId: Int = 2       
val sellerItem = sellerAndItemId(0)
sellerItem._1 //res4: Int = 1
sellerItem._2 //res5: Int = 2
</code></pre>

<h3 id="用模式匹配增加tuple可读性:0cf58323c62a1ce60f25579926a25322">用模式匹配增加tuple可读性</h3>

<pre><code>val sampleList = List((1, 2, 3), (4, 5, 6), (7, 8, 9))
sampleList.map(x =&gt; s&quot;${x._1}_${x._2}_${x._3}&quot;)
//res0: List[String] = List(1_2_3, 4_5_6, 7_8_9)
sampleList.map {    
  case (orderId, shopId, itemId) =&gt;
    s&quot;${orderId}_${shopId}_$itemId&quot;
}   
//res1: List[String] = List(1_2_3, 4_5_6, 7_8_9)
</code></pre>

<p>上下两个map做了同样的事情,但下一个map为tuple中的三个值都给了名字,增加了代码的可读性.</p>

<h3 id="match和java和switch很像-但有区别:0cf58323c62a1ce60f25579926a25322">match和java和switch很像,但有区别</h3>

<ol>
<li>match是表达式,会返回值</li>
<li>match不需要”break”</li>
<li>如果没有任何符合要求的case,match会抛异常,因为是表达式</li>
<li>match可以匹配任何东西,switch只能匹配数字或字符串常量</li>
</ol>

<pre><code>//case如果是常量,就在值相等时匹配.
//如果是变量,就匹配任何值.
def describe(x: Any) = x match {
   case 5 =&gt; &quot;five&quot; 
   case true =&gt; &quot;truth&quot; 
   case &quot;hello&quot; =&gt; &quot;hi!&quot;    
   case Nil =&gt; &quot;the empty list&quot;
   case somethingElse =&gt; &quot;something else &quot; + somethingElse  
}   
</code></pre>

<p>case class,tuple以及列表都可以在匹配的同时捕获内部的内容.</p>

<pre><code>case class Sample(a:String,b:String,c:String,d:String,e:String)
def showContent(x: Any) =
 x match {      
  case Sample(a,b,c,d,e) =&gt; 
  s&quot;Sample $a.$b.$c.$d.$e&quot;  
  case (a,b,c,d,e) =&gt;   
  s&quot;tuple $a,$b,$c,$d,$e&quot;   
  case head::second::rest =&gt;    
  s&quot;list head:$head second:$second rest:$rest&quot;
}
</code></pre>

<h3 id="case-class:0cf58323c62a1ce60f25579926a25322">Case class</h3>

<ol>
<li>模式匹配过程中其实调用了类的unapply方法</li>
<li>Case class 是为模式匹配(以及其他一些方面)提供了特别的便利的类</li>
<li>Case class 还是普通的class,但是它自动为你实现了apply,unapply,toString等方法</li>
<li>其实tuple就是泛型的case class</li>
</ol>

<h2 id="用-option-代替-null:0cf58323c62a1ce60f25579926a25322">用 option 代替 null</h2>

<h3 id="null-的问题:0cf58323c62a1ce60f25579926a25322">null 的问题</h3>

<pre><code>Map&lt;String, String&gt; map = ???
String valFor2014 = map.get(“1024”); // null

if (valFor1024 == null)
    abadon();
else doSomething();
</code></pre>

<ul>
<li>null到底代表key找不到还是说1024对应的值就是null?</li>
<li>某年某月某日,我把为null则abandon这段代码写了100遍.</li>
</ul>

<h3 id="option介绍:0cf58323c62a1ce60f25579926a25322">option介绍</h3>

<ul>
<li>option可以看作是一个容器,容器的size是1或0</li>
<li>Size为1的时候就是一个<code>Some[A](x: A)</code>,size为0的时候就是一个<code>None</code></li>
</ul>

<h3 id="看看scala的map:0cf58323c62a1ce60f25579926a25322">看看scala的map</h3>

<pre><code>def get(key: A): Option[B]

def getOrElse[B1 &gt;: B](key: A, default: =&gt; B1): B1 = get(key) match {
  case Some(v) =&gt; v
  case None =&gt; default
}
</code></pre>

<ul>
<li>可以区分Map中到底又没有这个key.</li>
<li>我见过许多java项目自己实现了<code>getOrElse</code>这个方法并放在一个叫做MapUtils的类里.</li>
<li>为什么java经过这么多代演进,Map仍然没有默认包含这个方法,一直想不通.
(写完这段突然发现java8开始包含getOrDefault了)</li>
</ul>

<h3 id="好像没有太大区别:0cf58323c62a1ce60f25579926a25322">好像没有太大区别?</h3>

<p>确实能够区分Map是无值还是值为null了.
但是if(为null) 则 abandon 要写一百遍.
<code>case Some(v) =&gt; v</code>
<code>case None =&gt; default</code>
似乎也得写一百遍.</p>

<p>不,不是这样的
不要忘了option是个容器
<a href="http://www.scala-lang.org/api/2.11.7/index.html#scala.Option">http://www.scala-lang.org/api/2.11.7/index.html#scala.Option</a></p>

<h3 id="试试容器里的各种方法:0cf58323c62a1ce60f25579926a25322">试试容器里的各种方法</h3>

<pre><code>val a: Option[String] = Some(&quot;1024&quot;)
val b: Option[String] = None
a.map(_.toInt)
//res0: Option[Int] = Some(1024)
b.map(_.toInt)
//res1: Option[Int] = None,不会甩exception
a.filter(_ == &quot;2048&quot;)
//res2: Option[String] = None
b.filter(_ == &quot;2048&quot;)
//res3: Option[String] = None
a.getOrElse(&quot;2048&quot;)
//res4: String = 1024
b.getOrElse(&quot;2048&quot;)
//res5: String = 2048
a.map(_.toInt)
  .map(_ + 1)
  .map(_ / 5)
  .map(_ / 2 == 0) //res6: Option[Boolean] = Some(false)
//如果是null,恐怕要一连check abandon四遍了
</code></pre>

<h3 id="option配合其他容器使用:0cf58323c62a1ce60f25579926a25322">option配合其他容器使用</h3>

<pre><code>val a: Seq[String] =
  Seq(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, null, &quot;4&quot;)
val b: Seq[Option[String]] =
  Seq(Some(&quot;1&quot;), Some(&quot;2&quot;), Some(&quot;3&quot;), None, Some(&quot;4&quot;))

a.filter(_ != null).map(_.toInt)
//res0: Seq[Int] = List(1, 2, 3, 4)
//如果你忘了检查,编译器是看不出来的,只能在跑崩的时候抛异常
b.flatMap(_.map(_.toInt))
//res1: Seq[Int] = List(1, 2, 3, 4)
</code></pre>

<ul>
<li>option帮助你把错误扼杀在编译阶段</li>
<li>flatMap则可以在过滤空值的同时将option恢复为原始数据.</li>
</ul>

<p>scala原生容器类都对option有良好支持</p>

<pre><code>Seq(1,2,3).headOption
//res0: Option[Int] = Some(1)

Seq(1,2,3).find(_ == 5)
//res1: Option[Int] = None

Seq(1,2,3).lastOption
//res2: Option[Int] = Some(3)

Vector(1,2,3).reduceLeft(_ + _)
//res3: Int = 6

Vector(1,2,3).reduceLeftOption(_ + _)
//res4: Option[Int] = Some(6)
//在vector为空的时候也能用

Seq(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, null, &quot;d&quot;).map(Option(_))
//res0: Seq[Option[String]] =
// List(Some(a), Some(b), Some(c), None, Some(d))
//原始数据转换成option也很方便

</code></pre>

<h2 id="用try类保存异常:0cf58323c62a1ce60f25579926a25322">用Try类保存异常</h2>

<h3 id="传统异常处理的局限性:0cf58323c62a1ce60f25579926a25322">传统异常处理的局限性</h3>

<pre><code>try {
  1024 / 0
} catch {
  case e: Throwable =&gt; e.printStackTrace()
}
</code></pre>

<p>用try-catch的模式,异常必须在抛出的时候马上处理.
然而在分布式计算中,我们很可能希望将异常集中到一起处理,来避免需要到每台机器上单独看错误日志的窘态.</p>

<pre><code> val seq = Seq(0, 1, 2, 3, 4)
 //seq: Seq[Int] = List(0, 1, 2, 3, 4)

val seqTry = seq.map(x =&gt; Try {
  20 / x
})
//seqTry: Seq[scala.util.Try[Int]] = List(Failure(java.lang.ArithmeticException: devide by zero),Success(20), Success(10), Success(6), Success(5))

val succSeq = seqTry.flatMap(_.toOption)
//succSeq: Seq[Int] = List(20, 10, 6, 5) Try可以转换成Option
val succSeq2 = seqTry.collect {
  case Success(x) =&gt; x
}
//succSeq2: Seq[Int] = List(20, 10, 6, 5) 和上一个是一样的
val failSeq: Seq[Throwable] = seqTry.collect {
  case Failure(e) =&gt; e
}
//failSeq: Seq[Throwable] = List(java.lang.ArithmeticException: devide by zero)
</code></pre>

<p>Try实例可以序列化,并且在机器间传送.</p>

<h2 id="函数是一等公民:0cf58323c62a1ce60f25579926a25322">函数是一等公民</h2>

<h3 id="一个需求:0cf58323c62a1ce60f25579926a25322">一个需求</h3>

<ul>
<li>假设我们需要检查许多的数字是否符合某一范围</li>
<li>范围存储在外部系统中,并且可能随时更改</li>
<li>数字范围像这样存储着”&gt;= 3,&lt; 7”</li>
</ul>

<p>一个java版本</p>

<pre><code>List&lt;String&gt; params = new LinkedList&lt;&gt;();
List&lt;Integer&gt; nums = new LinkedList&lt;&gt;();
List&lt;String&gt; marks = new LinkedList&lt;&gt;();

public JavaRangeMatcher(List&lt;String&gt; params) {
    this.params = params;
    for (String param : params) {
        String[] markNum = param.split(&quot; &quot;);
        marks.add(markNum[0]);
        nums.add(Integer.parseInt(markNum[1]));
    }
}

public boolean check(int input) {
    for (int i = 0; i &lt; marks.size(); i++) {
        int num = nums.get(i);
        String mark = marks.get(i);
        if (mark.equals(&quot;&gt;&quot;) &amp;&amp; input &lt;= num) return false;
        if (mark.equals(&quot;&gt;=&quot;) &amp;&amp; input &lt; num) return false;
        if (mark.equals(&quot;&lt;&quot;) &amp;&amp; input &gt;= num) return false;
        if (mark.equals(&quot;&lt;=&quot;) &amp;&amp; input &gt; num) return false;
    }
    return true;
}

List&lt;String&gt; paramsList = new LinkedList&lt;String&gt;() {{
    add(“&gt;= 3”);
    add(“&lt; 7”);
}};
JavaRangeMatcher matcher = new JavaRangeMatcher(paramsList);
int[] inputs = new int[]{1, 3, 5, 7, 9};
for (int input : inputs) {
    System.out.println(matcher.check(input));
}
//给自己有限的时间,想想又没有性能优化的余地
//我们一起来跑跑看
</code></pre>

<p>一个 scala 版本</p>

<pre><code>def exprToInt(expr: String): Int =&gt; Boolean = {
  val Array(mark, num, _*) = expr.split(&quot; &quot;)
  val numInt = num.toInt
  mark match {
    case &quot;&lt;&quot; =&gt; numInt.&gt;
    case &quot;&gt;&quot; =&gt; numInt.&lt;
    case &quot;&gt;=&quot; =&gt; numInt.&lt;=
    case &quot;&lt;=&quot; =&gt; numInt.&gt;=
  } //返回函数的函数
}

case class RangeMatcher(range: Seq[String]) {
  val rangeFunc: Seq[(Int) =&gt; Boolean] = range.map(exprToInt)

  def check(input: Int) = rangeFunc.forall(_(input))
}

def main(args: Array[String]) {
  val requirements = Seq(&quot;&gt;= 3&quot;, &quot;&lt; 7&quot;)
  val rangeMatcher = RangeMatcher(requirements)
  val results = Seq(1, 3, 5, 7, 9).map(rangeMatcher.check)
  println(results.mkString(&quot;,&quot;))
  //false,true,true,false,false
}

</code></pre>

<h2 id="关于性能:0cf58323c62a1ce60f25579926a25322">关于性能</h2>

<p>这里有一个<a href="http://benchmarksgame.alioth.debian.org/u64/performance.php?test=binarytrees&amp;sort=elapsed">性能测试</a>网站</p>

<p>我对于网站测试的结果,我总结的情况就是两点.
1. 排在后面的基本都是动态类型语言,静态类型语言相对容易优化到性能差不多的结果.
2. 同一个语言代码写得好差产生的性能差异,远远比各种语言最好的代码性能差异大.</p>

<h3 id="总的来说-程序员越自由-程序性能就越差:0cf58323c62a1ce60f25579926a25322">总的来说,程序员越自由,程序性能就越差</h3>

<p>不过也有返利,我们之前那个程序就是.</p>

<pre><code>//java版本
public static void main(String[] args) {
    List&lt;String&gt; paramsList = new LinkedList&lt;String&gt;() {{
        add(&quot;&gt;= 3&quot;);
        add(&quot;&lt; 7&quot;);
    }};
    JavaRangeMatcher matcher = new JavaRangeMatcher(paramsList);
    Random random = new Random();
    long timeBegin = System.currentTimeMillis();
    for (int i = 0; i &lt; 100000000; i++) {
        int input = random.nextInt() % 10;
        matcher.check(input);
    }
    long timeEnd = System.currentTimeMillis();
    System.out.println(&quot;java 消耗时间: &quot; + (timeEnd - timeBegin) + &quot; 毫秒&quot;);
    //java 消耗时间: 3263 毫秒
}
</code></pre>

<pre><code>//scala版本
def main(args: Array[String]) {
  val requirements = Seq(&quot;&gt;= 3&quot;, &quot;&lt; 7&quot;)
  val rangeMatcher = RangeMatcher(requirements)
  val timeBegin = System.currentTimeMillis()
  0 until 100000000 foreach {
    case _ =&gt;
      rangeMatcher.check(Random.nextInt(10))
  }
  val timeEnd = System.currentTimeMillis()
  println(s&quot;scala 消耗时间 ${timeEnd - timeBegin} 毫秒&quot;)
  //scala 消耗时间 2617 毫秒
}
</code></pre>

<p>想想这是为什么?</p>

<h2 id="推荐资源:0cf58323c62a1ce60f25579926a25322">推荐资源</h2>

<ul>
<li>尽情地使用worksheet吧!</li>
<li>尽情地用IDE查看标准库的源代码吧!</li>
<li>推荐coursera上的课程<a href="https://www.coursera.org/course/progfun">progfun</a>和<a href="https://www.coursera.org/course/reactive">reactive</a></li>
<li>尽情地查看文档,推荐软件Dash</li>
</ul>

	
			

			

			
				<div class="paging">
					<span class="paging-label">More Reading</span>
					

					
	            </div>
            
          </section>
          
          	
          
        
      <div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
		</ul>
	</div>

	<p>&copy; 2015. All rights reserved.</p>
</div>
    </div>
  </div>
	

	

  
<script data-no-instant>document.write('<script src="http://'
        + (location.host || 'localhost').split(':')[0]
		+ ':1313/livereload.js?mindelay=10"></'
        + 'script>')</script></body>
</html>